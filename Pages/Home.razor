@page "/"
@using p07_vimkeys_game.Components
@using p07_vimkeys_game.Domain.Entities
@using p07_vimkeys_game.Domain.ValueObjects
@inject IJSRuntime JSRuntime

<PageTitle>Vim Keys Game</PageTitle>

<style>
  .top-info>button {
    margin-inline: 2px;
  }
  .top-info {
    font-family: monospace;
    max-width: fit-content;
    margin-inline: auto;
  }
  button>h1 {
    margin-block: 1px;
    font-family: monospace;
  }
  .top-info>h1 {
    display: inline-block
  }
</style>

<div class="top-info">
<button><h1>&lt;SPACE&gt;@(game.State == GameState.Ready ? "Start" : "Stop")</h1></button>
<button @onclick="() => PromptKey(Direction.Left)"><h1>@keybindings[Direction.Left]⬅</h1></button>
<button @onclick="() => PromptKey(Direction.Down)"><h1>@keybindings[Direction.Down]⬇</h1></button>
<button @onclick="() => PromptKey(Direction.Up)"><h1>@keybindings[Direction.Up]⬆</h1></button>
<button @onclick="() => PromptKey(Direction.Right)"><h1>@keybindings[Direction.Right]➡</h1></button>
<h1>
| Score: @game.Scores.Item1.ToString("F2")s |
Best: @game.Scores.Item2.ToString("F2")s
</h1>
</div>

<DynamicComponent Type="@gridComponentType"
                  Parameters="@gridParameters" />

@code {
    // GAME MAKER DECIDES: Change to typeof(GridV1) for anchor-based rendering
    private Type gridComponentType = typeof(GridV2);

    private Game game = new Game();

    // Configurable keybindings
    private Dictionary<Direction, string> keybindings = new()
    {
        { Direction.Left, "h" },
        { Direction.Down, "j" },
        { Direction.Up, "k" },
        { Direction.Right, "l" }
    };

    private Dictionary<string, object> gridParameters => new()
    {
        { "Game", game }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("registerKeyHandler", DotNetObjectReference.Create(this));
        }
    }

    private async Task PromptKey(Direction direction)
    {
        var directionName = direction.ToString().ToUpper();
        var currentKey = keybindings[direction];
        var newKey = await JSRuntime.InvokeAsync<string>("promptForKey", directionName, currentKey);
        if (!string.IsNullOrEmpty(newKey))
        {
            keybindings[direction] = newKey;
            StateHasChanged();
        }
    }

    private void StartGame()
    {
        game.Start();
        StateHasChanged();
    }

    private void ResetGame()
    {
        game.Reset();
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleKeyDown(string key, bool ctrlKey, bool shiftKey, bool altKey, bool metaKey)
    {
        // Centralized keyboard shortcut dispatch logic

        // Handle configurable navigation keys
        if (keybindings.ContainsValue(key))
        {
            var direction = keybindings.First(kvp => kvp.Value == key).Key;
            game.MovePlayer(direction);
            StateHasChanged();
        }
        // Handle space key for Start/Reset game
        else if (key == " ")
        {
            if (game.State == GameState.Ready)
            {
                StartGame();
            }
            else if (game.State == GameState.Playing)
            {
                ResetGame();
            }
        }
    }
}
