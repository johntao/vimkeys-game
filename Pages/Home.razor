@page "/"
@using p07_vimkeys_game.Components
@using p07_vimkeys_game.Domain.Entities
@using p07_vimkeys_game.Domain.ValueObjects
@using System.ComponentModel.DataAnnotations
@inject IJSRuntime JS
@implements IValidatableObject

<PageTitle>Vim Keys Game</PageTitle>

<div class="top-info">
<button onclick="configDialog.showModal()"><h1>Config Keys</h1></button>
<h1>
Keys: &lt;SPACE&gt;@(game.State == GameState.Ready ? "Start" : "Stop")
@string.Join("\n", Qqq.Values.Select(q => $"{q.CurrentDef}{q.Icon}"))
| Score: @game.Scores.Item1.ToString("F2")s |
Best: @game.Scores.Item2.ToString("F2")s
</h1>
</div>

<dialog id="configDialog" @ref="configDialog" @onclose="OnDialogClose" closedby="any">
  <h2>Configure Keybindings</h2>
  <EditForm Model="this" method="dialog" OnValidSubmit="OnValidFormSubmit" OnInvalidSubmit="OnInvalidFormSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <div class="form-row">
      <label>Left ⬅</label>
      <span class="system-key">@Qqq[Direction.Left].SystemDef</span>
      <InputText @bind-Value="Qqq[Direction.Left].UserDef" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Down ⬇</label>
      <span class="system-key">@Qqq[Direction.Down].SystemDef</span>
      <InputText @bind-Value="Qqq[Direction.Down].UserDef" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Up ⬆</label>
      <span class="system-key">@Qqq[Direction.Up].SystemDef</span>
      <InputText @bind-Value="Qqq[Direction.Up].UserDef" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Right ➡</label>
      <span class="system-key">@Qqq[Direction.Right].SystemDef</span>
      <InputText @bind-Value="Qqq[Direction.Right].UserDef" maxlength="1" />
    </div>
    <button @ref="myForm" style="display:none">Submit</button>
  </EditForm>
</dialog>

<DynamicComponent Type="@gridComponentType"
                  Parameters="@gridParameters" />

@code {
    // GAME MAKER DECIDES: Change to typeof(GridV1) for anchor-based rendering
    private Type gridComponentType = typeof(GridV2);

    private Game game = new Game();

    public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        var duplicates = Qqq.Values
            .Select(d => d.CurrentDef)
            .GroupBy(k => k)
            .Where(g => g.Count() > 1);
        if (duplicates.Any())
        {
            yield return new ValidationResult(
                $"Duplicate keys detected! Each direction must have a unique key."
            );
        }
    }

  public static readonly Dictionary<Direction, Domain01> Qqq = new()
  {
      { Direction.Left, new() { Key = Direction.Left, Name = "Left", SystemDef = "h", Icon = "⬅" } },
      { Direction.Down, new() { Key = Direction.Down, Name = "Down", SystemDef = "j", Icon = "⬇" } },
      { Direction.Up, new() { Key = Direction.Up, Name = "Up", SystemDef = "k", Icon = "⬆" } },
      { Direction.Right, new() { Key = Direction.Right, Name = "Right", SystemDef = "l", Icon = "➡" } },
  };

    // Reference to the dialog element
    private ElementReference configDialog, myForm;

    private Dictionary<string, object> gridParameters => new()
    {
        { "Game", game }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("registerKeyHandler", DotNetObjectReference.Create(this));
        }
    }

    private async Task OnValidFormSubmit()
    {
        var isOpen = await JS.InvokeAsync<bool>("getPropertyAny", configDialog, "open");
        if (isOpen)
        {
            await JS.InvokeVoidAsync("callFunctionAny", configDialog, "close");
        }
    }

    private async Task OnInvalidFormSubmit()
    {
        var isOpen = await JS.InvokeAsync<bool>("getPropertyAny", configDialog, "open");
        if (!isOpen)
        {
            await JS.InvokeVoidAsync("callFunctionAny", configDialog, "showModal");
        }
    }

    private async Task OnDialogClose()
    {
        await JS.InvokeVoidAsync("callFunctionAny", myForm, "click");
    }

    private void StartGame()
    {
        game.Start();
        StateHasChanged();
    }

    private void ResetGame()
    {
        game.Reset();
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleKeyDown(string key, bool ctrlKey, bool shiftKey, bool altKey, bool metaKey)
    {
        // Centralized keyboard shortcut dispatch logic

        // Handle configurable navigation keys - check effective keys
        var matchingEntry = Qqq.FirstOrDefault(q => q.Value.CurrentDef == key);
        var matchingDirection = matchingEntry.Key != Direction.None ? matchingEntry.Key : Direction.None;

        if (matchingDirection != Direction.None)
        {
            game.MovePlayer(matchingDirection);
            StateHasChanged();
        }
        // Handle space key for Start/Reset game
        else if (key == " ")
        {
            if (game.State == GameState.Ready)
            {
                StartGame();
            }
            else if (game.State == GameState.Playing)
            {
                ResetGame();
            }
        }
    }
}
