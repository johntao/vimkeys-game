@page "/"
@using p07_vimkeys_game.Components
@using p07_vimkeys_game.Domain.Entities
@using p07_vimkeys_game.Domain.ValueObjects
@using System.ComponentModel.DataAnnotations
@inject IJSRuntime JS

<PageTitle>Vim Keys Game</PageTitle>

<div class="top-info">
<button onclick="configDialog.showModal()"><h1>Config Keys</h1></button>
<h1>
Keys: &lt;SPACE&gt;@(game.State == GameState.Ready ? "Start" : "Stop")
@GetEffectiveKey(Direction.Left)⬅
@GetEffectiveKey(Direction.Down)⬇
@GetEffectiveKey(Direction.Up)⬆
@GetEffectiveKey(Direction.Right)➡
| Score: @game.Scores.Item1.ToString("F2")s |
Best: @game.Scores.Item2.ToString("F2")s
</h1>
</div>

<dialog id="configDialog" @ref="configDialog" @onclose="OnDialogClose" closedby="any">
  <h2>Configure Keybindings</h2>
  <EditForm Model="formModel" method="dialog" OnValidSubmit="OnValidFormSubmit" OnInvalidSubmit="OnInvalidFormSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <div class="form-row">
      <label>Left ⬅</label>
      <span class="system-key">@systemKeybindings[Direction.Left]</span>
      <InputText @bind-Value="formModel.Left" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Down ⬇</label>
      <span class="system-key">@systemKeybindings[Direction.Down]</span>
      <InputText @bind-Value="formModel.Down" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Up ⬆</label>
      <span class="system-key">@systemKeybindings[Direction.Up]</span>
      <InputText @bind-Value="formModel.Up" maxlength="1" />
    </div>
    <div class="form-row">
      <label>Right ➡</label>
      <span class="system-key">@systemKeybindings[Direction.Right]</span>
      <InputText @bind-Value="formModel.Right" maxlength="1" />
    </div>
    <button @ref="myForm" style="display:none">Submit</button>
  </EditForm>
</dialog>

<DynamicComponent Type="@gridComponentType"
                  Parameters="@gridParameters" />

@code {
    // GAME MAKER DECIDES: Change to typeof(GridV1) for anchor-based rendering
    private Type gridComponentType = typeof(GridV2);

    private Game game = new Game();

    // Direction metadata for UI rendering
    private static readonly Direction[] AllDirections = { Direction.Left, Direction.Down, Direction.Up, Direction.Right };

    private static readonly Dictionary<Direction, (string Arrow, string Label)> DirectionMetadata = new()
    {
        { Direction.Left, ("⬅", "Left") },
        { Direction.Down, ("⬇", "Down") },
        { Direction.Up, ("⬆", "Up") },
        { Direction.Right, ("➡", "Right") }
    };

    // System default keybindings
    private Dictionary<Direction, string> systemKeybindings = new()
    {
        { Direction.Left, "h" },
        { Direction.Down, "j" },
        { Direction.Up, "k" },
        { Direction.Right, "l" }
    };

    // User-defined keybindings (overrides system defaults)
    private Dictionary<Direction, string> userKeybindings = AllDirections.ToDictionary(d => d, d => "");

    // Reference to the dialog element
    private ElementReference configDialog, myForm;

    // Form model for keybinding configuration
    private KeybindingFormModel formModel = new();

    [NoDuplicateKeys(ErrorMessage = "Duplicate keys detected. Please use unique keys for each direction.")]
    public class KeybindingFormModel
    {
        public string Left { get; set; } = "";
        public string Down { get; set; } = "";
        public string Up { get; set; } = "";
        public string Right { get; set; } = "";

        // Get keybinding value by direction
        public string GetKey(Direction direction) => direction switch
        {
            Direction.Left => Left,
            Direction.Down => Down,
            Direction.Up => Up,
            Direction.Right => Right,
            _ => ""
        };

        // Set keybinding value by direction
        public void SetKey(Direction direction, string value)
        {
            switch (direction)
            {
                case Direction.Left: Left = value; break;
                case Direction.Down: Down = value; break;
                case Direction.Up: Up = value; break;
                case Direction.Right: Right = value; break;
            }
        }
    }

    // Custom validation attribute for duplicate key detection
    public class NoDuplicateKeysAttribute : ValidationAttribute
    {
        protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
        {
            if (value is KeybindingFormModel model)
            {
                var keys = new[] { model.Left, model.Down, model.Up, model.Right }
                    .Where(k => !string.IsNullOrEmpty(k))
                    .ToList();

                if (keys.Count != keys.Distinct().Count())
                {
                    return new ValidationResult(ErrorMessage ?? "Duplicate keys detected.");
                }
            }

            return ValidationResult.Success;
        }
    }

    private string GetEffectiveKey(Direction direction)
    {
        var userKey = userKeybindings[direction];
        return string.IsNullOrEmpty(userKey) ? systemKeybindings[direction] : userKey;
    }

    private Dictionary<string, object> gridParameters => new()
    {
        { "Game", game }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("registerKeyHandler", DotNetObjectReference.Create(this));
        }
    }

    private async Task OnValidFormSubmit()
    {
        var isOpen = await JS.InvokeAsync<bool>("getPropertyAny", configDialog, "open");
        if (isOpen)
        {
            await JS.InvokeVoidAsync("callFunctionAny", configDialog, "close");
        }

        // Update all user keybindings from form model
        foreach (var direction in AllDirections)
        {
            userKeybindings[direction] = formModel.GetKey(direction) ?? "";
        }
    }

    private async Task OnInvalidFormSubmit()
    {
        var isOpen = await JS.InvokeAsync<bool>("getPropertyAny", configDialog, "open");
        if (!isOpen)
        {
            await JS.InvokeVoidAsync("callFunctionAny", configDialog, "showModal");
        }
    }

    private async Task OnDialogClose()
    {
        await JS.InvokeVoidAsync("callFunctionAny", myForm, "click");
    }

    private void StartGame()
    {
        game.Start();
        StateHasChanged();
    }

    private void ResetGame()
    {
        game.Reset();
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleKeyDown(string key, bool ctrlKey, bool shiftKey, bool altKey, bool metaKey)
    {
        // Centralized keyboard shortcut dispatch logic

        // Handle configurable navigation keys - check effective keys
        var matchingDirection = AllDirections.FirstOrDefault(d => GetEffectiveKey(d) == key);

        if (matchingDirection != default(Direction))
        {
            game.MovePlayer(matchingDirection);
            StateHasChanged();
        }
        // Handle space key for Start/Reset game
        else if (key == " ")
        {
            if (game.State == GameState.Ready)
            {
                StartGame();
            }
            else if (game.State == GameState.Playing)
            {
                ResetGame();
            }
        }
    }
}
